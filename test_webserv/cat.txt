Config 

Detection des elements obligatoires :
	ajouter une fonction dans chaque class (Server, location) pour checker si tous les elem mandatory sont presents

Server + plusieurs spaces + { mal gere = indiquer une erreur specifique "keyword server need an opening bracket 1 space after"

Mot cle n' existant pas = "keyword unsupported"

// Config.hpp
#ifndef CONFIG_HPP
#define CONFIG_HPP

#include <vector>
#include "Server.hpp"

class Config {
public:
    std::vector<Server> servers;

    // Méthode pour ajouter un serveur
    void addServer(const Server& server) {
        servers.push_back(server);
    }
};

#endif // CONFIG_HPP
// ConfigParser.hpp
#ifndef CONFIGPARSER_HPP
#define CONFIGPARSER_HPP

#include <string>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <stack>
#include <algorithm>
#include "Config.hpp"

class ConfigParser {
public:
    ConfigParser(const std::string& filepath);
    bool parse(Config& config);
    std::string getError() const;

private:
    std::string filepath;
    std::string error;

    // Méthodes utilitaires
    std::string trim(const std::string& str);
    bool startsWith(const std::string& str, const std::string& prefix);
};

#endif // CONFIGPARSER_HPP
// include/HTTPHandler.hpp
#ifndef HTTPHANDLER_HPP
#define HTTPHANDLER_HPP

#include "HTTPRequest.hpp"
#include "HTTPResponse.hpp"
#include "Webserv.hpp"//a voir


class HTTPHandler {
public:
    HTTPHandler();
    ~HTTPHandler();
    // Traite la requête et retourne la réponse
    HTTPResponse handleRequest(const HTTPRequest& request);

    // Méthodes pour gérer les différentes méthodes HTTP
    HTTPResponse handleGET(const HTTPRequest& request);
    HTTPResponse handlePOST(const HTTPRequest& request);
    HTTPResponse handleDELETE(const HTTPRequest& request);

    // Génère une réponse d'erreur avec le code et le message spécifiés
    HTTPResponse generateErrorResponse(int code, const std::string& message);

    private:
    // Exécute un script CGI et retourne la réponse générée
    HTTPResponse detectCGI(const HTTPRequest& request);
    HTTPResponse execute_cgi(const std::string& script_path, const std::string& query_string);
    std::string convert_line_endings(const std::string& str);
    
    // Méthode pour gérer les téléversements de fichiers (si nécessaire)
    HTTPResponse handleFileUpload(const HTTPRequest& request);
};

#endif // HTTPHANDLER_HPP
// include/HTTPRequest.hpp
#ifndef HTTPREQUEST_HPP
#define HTTPREQUEST_HPP

#include <string>
#include <map>

class HTTPRequest {
public:
    HTTPRequest();
    ~HTTPRequest();

    // Parse la requête brute et retourne true si réussi
    bool parse(const std::string& raw_request);

    // Getters
    std::string getMethod() const;
    std::string getURI() const;
    std::string getVersion() const;
    std::map<std::string, std::string> getHeaders() const;
    std::string getBody() const;

private:
    std::string method;
    std::string uri;
    std::string version;
    std::map<std::string, std::string> headers;
    std::string body;

    // Méthodes internes de parsing
    bool parseRequestLine(const std::string& line);
    bool parseHeaderLine(const std::string& line);
};

#endif // HTTPREQUEST_HPP
// include/HTTPResponse.hpp
#ifndef HTTPRESPONSE_HPP
#define HTTPRESPONSE_HPP

#include <string>
#include <map>

class HTTPResponse {
public:
    // Constructeur et destructeur
    HTTPResponse();
    HTTPResponse(int code);
    ~HTTPResponse();

    // Méthodes setters
    void setStatusCode(int code);
    void setReasonPhrase(const std::string& reason);
    void setHeader(const std::string& key, const std::string& value);
    void setBody(const std::string& body_content);

    // Méthode pour convertir la réponse en chaîne de caractères
    std::string toString() const;

    // **Nouvelles Méthodes Getters**
    int getStatusCode() const;
    std::string getReasonPhrase() const;
    const std::map<std::string, std::string>& getHeaders() const;
    const std::string& getBody() const;

private:
    int status_code;
    std::string reason_phrase;
    std::map<std::string, std::string> headers;
    std::string body;
};

#endif // HTTPRESPONSE_HPP
// Location.hpp
#ifndef LOCATION_HPP
#define LOCATION_HPP

#include <string>
#include <vector>
#include <map>

class Location {
public:
    // Directives de location
    std::string path;
    std::vector<std::string> methods;
    bool autoindex;
    std::string index;
    std::string upload_dir;
    bool cgi;
    std::string redirect;
    std::string root;

    // Constructeur
    Location() : autoindex(false), cgi(false) {}
};

#endif // LOCATION_HPP
// Server.hpp
#ifndef SERVER_HPP
#define SERVER_HPP

#include <string>
#include <vector>
#include <map>
#include "Location.hpp"

class Server {
public:
    // Directives de server
    std::string listen_ip;
    int listen_port;
    std::vector<std::string> server_names;
    std::string root;
    int client_max_body_size;
    std::map<int, std::string> error_pages;
    std::vector<Location> locations;

    // Constructeur 
	//Attention le listen port par defaut est peut etre gemnerateur d' erreurs
    Server() : listen_port(80), client_max_body_size(0) {}
};

#endif // SERVER_HPP
// ServerManager.hpp
#ifndef SERVERMANAGER_HPP
#define SERVERMANAGER_HPP

// #include <vector>
#include "Server.hpp"
#include "Config.hpp"

struct ServerSocket {
    int socket_fd;
    const Server* server; // Pointeur vers la configuration correspondante
};

class ServerManager {
public:
    ServerManager(const Config& config);
    ~ServerManager();
    bool setupServers();
    const std::vector<ServerSocket>& getServerSockets() const;

private:
    const Config& config;
    std::vector<ServerSocket> server_sockets;
    std::map<std::pair<std::string, int>, const Server*> unique_servers;
};

#endif
#ifndef WEBSERV_HPP
#define WEBSERV_HPP

#include <sys/stat.h>
#include <cerrno>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sstream>
#include <fstream>
#include <sys/wait.h>
#include <signal.h>
#include <vector>
#include <poll.h>
#include <fcntl.h>
#include <netinet/tcp.h>
#include <map>
#include <iostream>
#include <string>
#include <unistd.h>
#include <cstring>
#include <sys/types.h>
#include <cstdlib>

// Inclure les nouvelles classes
#include "../includes/HTTPHandler.hpp"
#include "../includes/HTTPRequest.hpp"
#include "../includes/HTTPResponse.hpp"
#include "../includes/ServerManager.hpp"
#include "../includes/ConfigParser.hpp"
#include "../includes/Config.hpp"//contenu dans configparser
#include "../includes/Location.hpp"//contenu dans configparser
#include "../includes/Server.hpp"//contenu dans configparser


// Constantes
const int PORT = 8080;
const int BUFFER_SIZE = 4096;

// Déclaration globale du socket serveur
extern int server_fd;









#endif