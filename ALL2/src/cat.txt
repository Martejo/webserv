#include "../includes/Config.hpp"
#include <iostream>

Config::Config()
    : clientMaxBodySize_(0)
{
}

Config::~Config()
{
    // Supprimer les objets Server alloués dynamiquement
    for (size_t i = 0; i < servers_.size(); ++i)
    {
        delete servers_[i];
    }
    servers_.clear();
}

void Config::setClientMaxBodySize(size_t size)
{
    clientMaxBodySize_ = size;
}

size_t Config::getClientMaxBodySize() const
{
    return clientMaxBodySize_;
}

void Config::addErrorPage(int statusCode, const std::string &uri)
{
    errorPages_[statusCode] = uri;
}

const std::map<int, std::string> &Config::getErrorPages() const
{
    return errorPages_;
}

std::string Config::getErrorPage(int errorCode) const
{
    std::map<int, std::string>::const_iterator it = errorPages_.find(errorCode);
    if (it != errorPages_.end())
        return it->second;
    else
        return ""; // Ou une valeur par défaut si nécessaire
}

void Config::setRoot(const std::string &root)
{
    root_ = root;
}

const std::string &Config::getRoot() const
{
    return root_;
}

void Config::setIndex(const std::string &index)
{
    index_ = index;
}

const std::string &Config::getIndex() const
{
    return index_;
}

void Config::addServer(Server* server)
{
    servers_.push_back(server);
}

const std::vector<Server*>& Config::getServers() const
{
    return servers_;
}

// DEBUG
void Config::displayConfig() const
{
    std::cout << "client_max_body_size global: " << this->getClientMaxBodySize() << std::endl;

    // Affichage des pages d'erreur globales
    const std::map<int, std::string> &globalErrorPages = this->getErrorPages();
    for (std::map<int, std::string>::const_iterator it = globalErrorPages.begin(); it != globalErrorPages.end(); ++it)
    {
        std::cout << "error_page " << it->first << " : " << it->second << std::endl;
    }

    const std::vector<Server*>& servers = this->getServers();
    for (size_t i = 0; i < servers.size(); ++i)
    {
        std::cout << "  Server [" << i << "] :" << std::endl;
        const Server* server = servers[i];
        server->displayServer();
    }
}
// Server.cpp
#include "../includes/Server.hpp"
#include "../includes/Location.hpp"
#include <iostream>
#include <arpa/inet.h> // Pour inet_ntop

Server::Server(const Config &config)
    : config_(config), clientMaxBodySizeIsSet_(false), rootIsSet_(false), indexIsSet_(false),
      host_(INADDR_ANY), port_(htons(8080)) // Valeurs par défaut
{
}

Server::~Server()
{
}

void Server::addServerName(const std::string &serverName)
{
    serverNames_.push_back(serverName);
}

void Server::setRoot(const std::string &root)
{
    root_ = root;
    rootIsSet_ = true;
}

void Server::setIndex(const std::string &index)
{
    index_ = index;
    indexIsSet_ = true;
}

void Server::addErrorPage(int statusCode, const std::string &uri)
{
    errorPages_[statusCode] = uri;
}

void Server::setClientMaxBodySize(size_t size)
{
    clientMaxBodySize_ = size;
    clientMaxBodySizeIsSet_ = true;
}

uint32_t Server::getHost() const
{
    return host_;
}

uint16_t Server::getPort() const
{
    return port_;
}

void Server::setHost(uint32_t host)
{
    host_ = host;
}

void Server::setPort(uint16_t port)
{
    port_ = port;
}

const std::vector<std::string> &Server::getServerNames() const
{
    return serverNames_;
}

const std::string &Server::getRoot() const
{
    if (rootIsSet_)
        return root_;
    else
        return config_.getRoot();
}

const std::string &Server::getIndex() const
{
    if (indexIsSet_)
        return index_;
    else
        return config_.getIndex();
}

const std::map<int, std::string> &Server::getErrorPages() const
{
    if (!errorPages_.empty())
        return errorPages_;
    else
        return config_.getErrorPages();
}

std::string Server::getErrorPage(int errorCode) const
{
    std::map<int, std::string>::const_iterator it = errorPages_.find(errorCode);
    if (it != errorPages_.end())
        return it->second;
    else
        return config_.getErrorPage(errorCode);
}

size_t Server::getClientMaxBodySize() const
{
    if (clientMaxBodySizeIsSet_)
        return clientMaxBodySize_;
    else
        return config_.getClientMaxBodySize();
}

void Server::addLocation(const Location &location)
{
    locations_.push_back(location);
}

const std::vector<Location> &Server::getLocations() const
{
    return locations_;
}

// DEBUG
void Server::displayServer() const
{
    // Afficher l'adresse IP et le port
    char ipStr[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &host_, ipStr, INET_ADDRSTRLEN);
    std::cout << "  listen: " << ipStr << ":" << ntohs(port_) << std::endl;

    // Affichage des server_name du serveur
    const std::vector<std::string> &serverNames = this->getServerNames();
    for (size_t j = 0; j < serverNames.size(); ++j)
    {
        std::cout << "  server_name: " << serverNames[j] << std::endl;
    }

    // Affichage des pages d'erreur du serveur
    const std::map<int, std::string> &serverErrorPages = this->getErrorPages();
    for (std::map<int, std::string>::const_iterator it = serverErrorPages.begin(); it != serverErrorPages.end(); ++it)
    {
        std::cout << "  error_page " << it->first << " : " << it->second << std::endl;
    }

    // Affichage du contenu des Locations du serveur
    const std::vector<Location> &locations = this->getLocations();
    for (size_t k = 0; k < locations.size(); ++k)
    {
        const Location &location = locations[k];
        location.displayLocation();
    }
}
#include "../includes/Location.hpp"
#include "../includes/Server.hpp"
#include <iostream>

Location::Location(const Server &server, const std::string &path)
    : server_(server),                 // Initializes first (as declared)
      clientMaxBodySizeIsSet_(false),  // Second
      rootIsSet_(false),               // Third
      indexIsSet_(false),              // Fourth
      clientMaxBodySize_(0),           // Fifth (default value)
      root_(""),                       // Sixth (default value)
      index_(""),                      // Seventh (default value)
      errorPages_(),                   // Eighth (default initialization)
      path_(path),                     // Ninth
      allowedMethods_(),               // Tenth (default initialization)
      redirection_(""),                // Eleventh (default value)
      autoIndex_(false),               // Twelfth
      cgiExtension_(""),               // Thirteenth (default value)
      uploadEnable_(false),            // Fourteenth
      uploadStore_("")                 // Fifteenth (default value)
{
}

Location::~Location()
{
}

void Location::setPath(const std::string &path)
{
    path_ = path;
}

const std::string &Location::getPath() const
{
    return path_;
}

void Location::setAllowedMethods(const std::vector<std::string> &methods)
{
    allowedMethods_ = methods;
}

const std::vector<std::string> &Location::getAllowedMethods() const
{
    return allowedMethods_;
}

void Location::setRedirection(const std::string &redirection)
{
    redirection_ = redirection;
}

const std::string &Location::getRedirection() const
{
    return redirection_;
}

void Location::setRoot(const std::string &root)
{
    root_ = root;
    rootIsSet_ = true;
}

const std::string &Location::getRoot() const
{
    if (rootIsSet_)
        return root_;
    else
        return server_.getRoot();
}

void Location::setAutoIndex(bool autoIndex)
{
    autoIndex_ = autoIndex;
}

bool Location::getAutoIndex() const
{
    return autoIndex_;
}

void Location::setIndex(const std::string &index)
{
    index_ = index;
    indexIsSet_ = true;
}

const std::string &Location::getIndex() const
{
    if (indexIsSet_)
        return index_;
    else
        return server_.getIndex();
}

void Location::setCgiExtension(const std::string &extension)
{
    cgiExtension_ = extension;
}

const std::string &Location::getCgiExtension() const
{
    return cgiExtension_;
}

void Location::setUploadEnable(bool enable)
{
    uploadEnable_ = enable;
}

bool Location::getUploadEnable() const
{
    return uploadEnable_;
}

void Location::setUploadStore(const std::string &uploadStore)
{
    uploadStore_ = uploadStore;
}

const std::string &Location::getUploadStore() const
{
    return uploadStore_;
}

void Location::setClientMaxBodySize(size_t size)
{
    clientMaxBodySize_ = size;
    clientMaxBodySizeIsSet_ = true;
}

size_t Location::getClientMaxBodySize() const
{
    if (clientMaxBodySizeIsSet_)
        return clientMaxBodySize_;
    else
        return server_.getClientMaxBodySize();
}

void Location::addErrorPage(int statusCode, const std::string &uri)
{
    errorPages_[statusCode] = uri;
}

const std::map<int, std::string> &Location::getErrorPages() const
{
    if (!errorPages_.empty())
        return errorPages_;
    else
        return server_.getErrorPages();
}

std::string Location::getErrorPage(int errorCode) const
{
    std::map<int, std::string>::const_iterator it = errorPages_.find(errorCode);
    if (it != errorPages_.end())
        return it->second;
    else
        return server_.getErrorPage(errorCode);
}

// DEBUG
void Location::displayLocation() const
{
    std::cout << "  Location " << this->getPath() << ":" << std::endl;
    std::cout << "    root: " << this->getRoot() << std::endl;
    std::cout << "    index: " << this->getIndex() << std::endl;
    std::cout << "    autoindex: " << (this->getAutoIndex() ? "on" : "off") << std::endl;

    // Afficher les méthodes autorisées
    const std::vector<std::string> &methods = this->getAllowedMethods();
    if (!methods.empty())
    {
        std::cout << "    allowed_methods:";
        for (size_t m = 0; m < methods.size(); ++m)
        {
            std::cout << " " << methods[m];
        }
        std::cout << std::endl;
    }

    // Afficher d'autres informations si nécessaire
    if (!this->getRedirection().empty())
    {
        std::cout << "    redirection: " << this->getRedirection() << std::endl;
    }

    if (!this->getCgiExtension().empty())
    {
        std::cout << "    cgi_pass: " << this->getCgiExtension() << std::endl;
    }

    std::cout << "    upload_enable: " << (this->getUploadEnable() ? "on" : "off") << std::endl;

    if (!this->getUploadStore().empty())
    {
        std::cout << "    upload_store: " << this->getUploadStore() << std::endl;
    }

    std::cout << "    client_max_body_size: " << this->getClientMaxBodySize() << std::endl;

    // Affichage des pages d'erreur de la location
    const std::map<int, std::string> &locationErrorPages = this->getErrorPages();
    for (std::map<int, std::string>::const_iterator it = locationErrorPages.begin(); it != locationErrorPages.end(); ++it)
    {
        std::cout << "    error_page " << it->first << " : " << it->second << std::endl;
    }
}
#include "../includes/DataSocket.hpp"
#include "../includes/HttpRequest.hpp"
#include "../includes/HttpResponse.hpp"
#include <unistd.h>
#include <cstring>
#include <iostream>
#include <algorithm>

DataSocket::DataSocket(int fd, const std::vector<Server*>& servers)
    : client_fd(fd), associatedServers(servers), selectedServer(NULL), requestParsed(false)
{
}

DataSocket::~DataSocket() {
    closeSocket();
}

bool DataSocket::receiveData() {
    std::cout << "DataSocket::receiveData() called." << std::endl;
    
    char buffer[4096];
    ssize_t bytesRead = recv(client_fd, buffer, sizeof(buffer), 0);
    if (bytesRead > 0) {
        std::string data(buffer, bytesRead);
        httpRequest.appendData(data);
        std::cout << "Received " << bytesRead << " bytes." << std::endl;
        
        // Tente de parser la requête après avoir reçu de nouvelles données
        if (httpRequest.parseRequest()) {
            requestParsed = true;
            return true;
        }
        return true; // Les données ont été reçues, mais la requête n'est peut-être pas encore complète
    } else if (bytesRead == 0) {
        // Le client a fermé la connexion
        std::cout << "Client closed the connection." << std::endl;
        return false;
    } else {
        // Gérer l'erreur
        std::cerr << "Error receiving data." << std::endl;
        return false;
    }
}

void DataSocket::closeSocket() {
    if (client_fd != -1) {
        close(client_fd);
        client_fd = -1;
        std::cout << "Socket closed." << std::endl;
    }
}

int DataSocket::getSocket() const {
    return client_fd;
}

bool DataSocket::isRequestComplete() const {
    return requestParsed && httpRequest.isComplete();
}

void DataSocket::processRequest() {
    std::cout << "DataSocket::processRequest() called." << std::endl;
    
    // La requête a déjà été parsée dans receiveData()
    // Récupérez l'en-tête Host
    std::string hostHeader = httpRequest.getHeader("Host");
    std::cout << "DataSocket::processRequest() Hostheader :" <<hostHeader  << std::endl;
    // std::cout << "associated servers size" << associatedServers.size()<< associatedServers[0]->getServerNames()[0]<< std::endl;//test

    // Sélectionnez le serveur approprié
    for (size_t i = 0; i < associatedServers.size(); ++i) {
        Server* server = associatedServers[i];
        const std::vector<std::string>& serverNames = server->getServerNames();
        if (std::find(serverNames.begin(), serverNames.end(), hostHeader) != serverNames.end()) {
            selectedServer = server;
            std::cout << "Selected server based on Host header." << std::endl;
            break;
        }
    }

    // Si aucun serveur n'a été trouvé, utilisez le premier par défaut (valider ce process avec le sujet)
    if (!selectedServer && !associatedServers.empty()) {
        selectedServer = associatedServers[0];
        std::cout << "No matching server found. Using the default server." << std::endl;
    }

    if (!selectedServer) {
        // Aucun serveur ne correspond, renvoyez une erreur 500
        httpResponse.setStatusCode(500);
        httpResponse.setBody("Internal Server Error: No matching server configuration.");
    } else {
        // Traitez la requête en utilisant selectedServer
        // Exemple simplifié : renvoyer "Hello World!" pour toutes les requêtes
        // Vous devrez implémenter la logique basée sur la configuration ici
        httpResponse.setStatusCode(200);
        httpResponse.setBody("Hello World!");
    }

    // Envoyez la réponse
    std::string responseStr = httpResponse.generateResponse();
    ssize_t bytesSent = send(client_fd, responseStr.c_str(), responseStr.size(), 0);
    if (bytesSent < 0) {
        std::cerr << "Error sending response." << std::endl;
    } else {
        std::cout << "Sent " << bytesSent << " bytes." << std::endl;
    }
}

Server* DataSocket::getSelectedServer() const {
    return selectedServer;
}
#include "../includes/HttpResponse.hpp"
#include <sstream>
#include <iostream>

HttpResponse::HttpResponse()
    : statusCode(200), reasonPhrase("OK"), body("") {
    headers["Content-Type"] = "text/html";
}

void HttpResponse::setStatusCode(int code) {
    statusCode = code;
    reasonPhrase = getDefaultReasonPhrase(code);
}

void HttpResponse::setReasonPhrase(const std::string& phrase) {
    reasonPhrase = phrase;
}

void HttpResponse::setBody(const std::string& bodyContent) {
    body = bodyContent;
    // Update Content-Length header
    std::ostringstream oss;
    oss << body.size();
    headers["Content-Length"] = oss.str();
}

void HttpResponse::setHeader(const std::string& headerName, const std::string& headerValue) {
    headers[headerName] = headerValue;
}

std::string HttpResponse::generateResponse() const {
    std::cout << "HTTPRESPONSE.CPP generateResponse()"<< std::endl;
    std::ostringstream response;

    // Status line
    response << "HTTP/1.1 " << statusCode << " " << reasonPhrase << "\r\n";

    // Headers
    for (std::map<std::string, std::string>::const_iterator it = headers.begin(); it != headers.end(); ++it) {
        response << it->first << ": " << it->second << "\r\n";
    }

    response << "\r\n"; // Empty line to separate headers from body

    // Body
    response << body;

    return response.str();
}

std::string HttpResponse::getDefaultReasonPhrase(int code) const {
    switch (code) {
        case 200: return "OK";
        case 201: return "Created";
        case 204: return "No Content";
        case 301: return "Moved Permanently";
        case 302: return "Found";
        case 400: return "Bad Request";
        case 403: return "Forbidden";
        case 404: return "Not Found";
        case 500: return "Internal Server Error";
        default:  return "OK";
    }
}
